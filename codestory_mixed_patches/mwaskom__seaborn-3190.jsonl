{
    "instance_id": "mwaskom__seaborn-3190",
    "model_name_or_path": "codestory-mixed",
    "model_patch": "diff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 6c7202c6..973f7615 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -626,7 +626,12 @@ class Plot:\n \n         \"\"\"\n         new = self._clone()\n-        new._scales.update(scales)\n+        for var, scale in scales.items():\n+            if var == 'color' and isinstance(scale, (list, tuple)) and all(isinstance(x, bool) for x in scale):\n+                # Convert boolean color data to a categorical scale\n+                new._scales[var] = Nominal([\"False\", \"True\"])\n+            else:\n+                new._scales[var] = scale\n         return new\n \n     def share(self, **shares: bool | str) -> Plot:\ndiff --git a/seaborn/_core/properties.py b/seaborn/_core/properties.py\nindex cd10e260..9b2bafe8 100644\n--- a/seaborn/_core/properties.py\n+++ b/seaborn/_core/properties.py\n@@ -565,6 +565,10 @@ class Color(Property):\n             return to_rgba_array(colors)[:, :3]\n \n     def infer_scale(self, arg: Any, data: Series) -> Scale:\n+        # Check for boolean data type\n+        if data.dtype == bool:\n+            return Nominal(arg if isinstance(arg, (dict, list)) else None)\n+\n         # TODO when inferring Continuous without data, verify type\n \n         # TODO need to rethink the variable type system\n@@ -612,6 +616,21 @@ class Color(Property):\n         n = len(levels)\n         values = scale.values\n \n+        # Special handling for boolean data\n+        if data.dtype == bool:\n+            if isinstance(values, dict):\n+                colors = [values.get(True, '#1f77b4'), values.get(False, '#ff7f0e')]\n+            elif isinstance(values, list) and len(values) >= 2:\n+                colors = values[:2]\n+            else:\n+                colors = ['#1f77b4', '#ff7f0e']  # Default colors for True and False\n+            colors = self._standardize_color_sequence(colors)\n+            \n+            def mapping(x):\n+                return np.where(x[:, np.newaxis], colors[0], colors[1])\n+            \n+            return mapping\n+\n         if isinstance(values, dict):\n             self._check_dict_entries(levels, values)\n             # TODO where to ensure that dict values have consistent representation?\n@@ -652,6 +671,11 @@ class Color(Property):\n         self, scale: Scale, data: Series\n     ) -> Callable[[ArrayLike], ArrayLike]:\n         \"\"\"Return a function that maps from data domain to color values.\"\"\"\n+        # Special handling for boolean data\n+        if data.dtype == bool:\n+            colors = self._get_boolean_colors(scale)\n+            return lambda x: np.where(x[:, np.newaxis], colors[0], colors[1])\n+\n         # TODO what is best way to do this conditional?\n         # Should it be class-based or should classes have behavioral attributes?\n         if isinstance(scale, Nominal):\n@@ -689,6 +713,16 @@ class Color(Property):\n \n         return _mapping\n \n+    def _get_boolean_colors(self, scale):\n+        \"\"\"Get colors for boolean data.\"\"\"\n+        if isinstance(scale.values, dict):\n+            colors = [scale.values.get(True, '#1f77b4'), scale.values.get(False, '#ff7f0e')]\n+        elif isinstance(scale.values, list) and len(scale.values) >= 2:\n+            colors = scale.values[:2]\n+        else:\n+            colors = ['#1f77b4', '#ff7f0e']  # Default colors for True and False\n+        return self._standardize_color_sequence(colors)\n+\n \n # =================================================================================== #\n # Properties that can take only two states\n",
    "resolved": false
}