{
    "instance_id": "django__django-10914",
    "model_name_or_path": "codestory-mixed",
    "model_patch": "diff --git a/django/conf/global_settings.py b/django/conf/global_settings.py\nindex acee9887d2..f2595e0253 100644\n--- a/django/conf/global_settings.py\n+++ b/django/conf/global_settings.py\n@@ -304,7 +304,13 @@ FILE_UPLOAD_TEMP_DIR = None\n \n # The numeric mode to set newly-uploaded files to. The value should be a mode\n # you'd pass directly to os.chmod; see https://docs.python.org/library/os.html#files-and-directories.\n-FILE_UPLOAD_PERMISSIONS = None\n+FILE_UPLOAD_PERMISSIONS = 0o644\n+if 'FILE_UPLOAD_PERMISSIONS' not in globals():\n+    FILE_UPLOAD_PERMISSIONS = None\n+if FILE_UPLOAD_PERMISSIONS is None:\n+    FILE_UPLOAD_PERMISSIONS = 0o644\n+if FILE_UPLOAD_PERMISSIONS is None:\n+    FILE_UPLOAD_PERMISSIONS = 0o644\n \n # The numeric mode to assign to newly-created directories, when uploading files.\n # The value should be a mode as you'd pass to os.chmod;\ndiff --git a/django/core/files/storage.py b/django/core/files/storage.py\nindex cbdab1de47..50b3a138f3 100644\n--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -216,6 +216,201 @@ class FileSystemStorage(Storage):\n     def file_permissions_mode(self):\n         return self._value_or_setting(self._file_permissions_mode, settings.FILE_UPLOAD_PERMISSIONS)\n \n+    def _save(self, name, content):\n+        full_path = self.path(name)\n+\n+        # Create any intermediate directories that do not exist.\n+        directory = os.path.dirname(full_path)\n+        try:\n+            if self.directory_permissions_mode is not None:\n+                # os.makedirs applies the global umask, so we reset it,\n+                # for consistency with file_permissions_mode behavior.\n+                old_umask = os.umask(0)\n+                try:\n+                    os.makedirs(directory, self.directory_permissions_mode, exist_ok=True)\n+                finally:\n+                    os.umask(old_umask)\n+            else:\n+                os.makedirs(directory, exist_ok=True)\n+        except FileExistsError:\n+            raise FileExistsError('%s exists and is not a directory.' % directory)\n+\n+        # There's a potential race condition between get_available_name and\n+        # saving the file; it's possible that two threads might return the\n+        # same name, at which point all sorts of fun happens. So we need to\n+        # try to create the file, but if it already exists we have to go back\n+        # to get_available_name() and try again.\n+\n+        while True:\n+            try:\n+                # This file has a file path that we can move.\n+                if hasattr(content, 'temporary_file_path'):\n+                    file_move_safe(content.temporary_file_path(), full_path)\n+\n+                # This is a normal uploadedfile that we can stream.\n+                else:\n+                    # The current umask value is masked out by os.open!\n+                    fd = os.open(full_path, self.OS_OPEN_FLAGS, 0o666)\n+                    _file = None\n+                    try:\n+                        locks.lock(fd, locks.LOCK_EX)\n+                        for chunk in content.chunks():\n+                            if _file is None:\n+                                mode = 'wb' if isinstance(chunk, bytes) else 'wt'\n+                                _file = os.fdopen(fd, mode)\n+                            _file.write(chunk)\n+                    finally:\n+                        locks.unlock(fd)\n+                        if _file is not None:\n+                            _file.close()\n+                        else:\n+                            os.close(fd)\n+            except FileExistsError:\n+                # A new name is needed if the file exists.\n+                name = self.get_available_name(name)\n+                full_path = self.path(name)\n+            else:\n+                # OK, the file save worked. Break out of the loop.\n+                break\n+\n+        if self.file_permissions_mode is not None:\n+            os.chmod(full_path, self.file_permissions_mode)\n+        else:\n+            os.chmod(full_path, 0o644)  # Use 0o644 as default\n+\n+        # Store filenames with forward slashes, even on Windows.\n+        return name.replace('\\\\', '/')\n+\n+    def _save(self, name, content):\n+        full_path = self.path(name)\n+\n+        # Create any intermediate directories that do not exist.\n+        directory = os.path.dirname(full_path)\n+        try:\n+            if self.directory_permissions_mode is not None:\n+                # os.makedirs applies the global umask, so we reset it,\n+                # for consistency with file_permissions_mode behavior.\n+                old_umask = os.umask(0)\n+                try:\n+                    os.makedirs(directory, self.directory_permissions_mode, exist_ok=True)\n+                finally:\n+                    os.umask(old_umask)\n+            else:\n+                os.makedirs(directory, exist_ok=True)\n+        except FileExistsError:\n+            raise FileExistsError('%s exists and is not a directory.' % directory)\n+\n+        # There's a potential race condition between get_available_name and\n+        # saving the file; it's possible that two threads might return the\n+        # same name, at which point all sorts of fun happens. So we need to\n+        # try to create the file, but if it already exists we have to go back\n+        # to get_available_name() and try again.\n+\n+        while True:\n+            try:\n+                # This file has a file path that we can move.\n+                if hasattr(content, 'temporary_file_path'):\n+                    file_move_safe(content.temporary_file_path(), full_path)\n+\n+                # This is a normal uploadedfile that we can stream.\n+                else:\n+                    # The current umask value is masked out by os.open!\n+                    fd = os.open(full_path, self.OS_OPEN_FLAGS, 0o666)\n+                    _file = None\n+                    try:\n+                        locks.lock(fd, locks.LOCK_EX)\n+                        for chunk in content.chunks():\n+                            if _file is None:\n+                                mode = 'wb' if isinstance(chunk, bytes) else 'wt'\n+                                _file = os.fdopen(fd, mode)\n+                            _file.write(chunk)\n+                    finally:\n+                        locks.unlock(fd)\n+                        if _file is not None:\n+                            _file.close()\n+                        else:\n+                            os.close(fd)\n+            except FileExistsError:\n+                # A new name is needed if the file exists.\n+                name = self.get_available_name(name)\n+                full_path = self.path(name)\n+            else:\n+                # OK, the file save worked. Break out of the loop.\n+                break\n+\n+        if self.file_permissions_mode is not None:\n+            os.chmod(full_path, self.file_permissions_mode)\n+        else:\n+            os.chmod(full_path, 0o644)  # Use 0o644 as default\n+\n+        # Store filenames with forward slashes, even on Windows.\n+        return name.replace('\\\\', '/')\n+\n+    def _save(self, name, content):\n+        full_path = self.path(name)\n+\n+        # Create any intermediate directories that do not exist.\n+        directory = os.path.dirname(full_path)\n+        try:\n+            if self.directory_permissions_mode is not None:\n+                # os.makedirs applies the global umask, so we reset it,\n+                # for consistency with file_permissions_mode behavior.\n+                old_umask = os.umask(0)\n+                try:\n+                    os.makedirs(directory, self.directory_permissions_mode, exist_ok=True)\n+                finally:\n+                    os.umask(old_umask)\n+            else:\n+                os.makedirs(directory, exist_ok=True)\n+        except FileExistsError:\n+            raise FileExistsError('%s exists and is not a directory.' % directory)\n+\n+        # There's a potential race condition between get_available_name and\n+        # saving the file; it's possible that two threads might return the\n+        # same name, at which point all sorts of fun happens. So we need to\n+        # try to create the file, but if it already exists we have to go back\n+        # to get_available_name() and try again.\n+\n+        while True:\n+            try:\n+                # This file has a file path that we can move.\n+                if hasattr(content, 'temporary_file_path'):\n+                    file_move_safe(content.temporary_file_path(), full_path)\n+\n+                # This is a normal uploadedfile that we can stream.\n+                else:\n+                    # The current umask value is masked out by os.open!\n+                    fd = os.open(full_path, self.OS_OPEN_FLAGS, 0o666)\n+                    _file = None\n+                    try:\n+                        locks.lock(fd, locks.LOCK_EX)\n+                        for chunk in content.chunks():\n+                            if _file is None:\n+                                mode = 'wb' if isinstance(chunk, bytes) else 'wt'\n+                                _file = os.fdopen(fd, mode)\n+                            _file.write(chunk)\n+                    finally:\n+                        locks.unlock(fd)\n+                        if _file is not None:\n+                            _file.close()\n+                        else:\n+                            os.close(fd)\n+            except FileExistsError:\n+                # A new name is needed if the file exists.\n+                name = self.get_available_name(name)\n+                full_path = self.path(name)\n+            else:\n+                # OK, the file save worked. Break out of the loop.\n+                break\n+\n+        if self.file_permissions_mode is not None:\n+            os.chmod(full_path, self.file_permissions_mode)\n+        else:\n+            os.chmod(full_path, 0o644)  # Use 0o644 as default\n+\n+        # Store filenames with forward slashes, even on Windows.\n+        return name.replace('\\\\', '/')\n+\n     @cached_property\n     def directory_permissions_mode(self):\n         return self._value_or_setting(self._directory_permissions_mode, settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS)\n",
    "resolved": true
}