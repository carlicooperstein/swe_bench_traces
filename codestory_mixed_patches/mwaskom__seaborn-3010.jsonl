{
    "instance_id": "mwaskom__seaborn-3010",
    "model_name_or_path": "codestory-mixed",
    "model_patch": "diff --git a/seaborn/_stats/regression.py b/seaborn/_stats/regression.py\nindex 7b7ddc8d..9bc14dd4 100644\n--- a/seaborn/_stats/regression.py\n+++ b/seaborn/_stats/regression.py\n@@ -20,16 +20,27 @@ class PolyFit(Stat):\n     gridsize: int = 100\n \n     def _fit_predict(self, data):\n-\n         x = data[\"x\"]\n         y = data[\"y\"]\n-        if x.nunique() <= self.order:\n-            # TODO warn?\n-            xx = yy = []\n-        else:\n-            p = np.polyfit(x, y, self.order)\n-            xx = np.linspace(x.min(), x.max(), self.gridsize)\n-            yy = np.polyval(p, xx)\n+\n+        # Check if the data is valid for fitting\n+        if not self._check_data(x, y):\n+            return pd.DataFrame(columns=[\"x\", \"y\"])\n+\n+        # Filter out missing values\n+        mask = x.notna() & y.notna()\n+        x_valid = x[mask]\n+        y_valid = y[mask]\n+\n+        if len(x_valid) == 0:\n+            return pd.DataFrame(columns=[\"x\", \"y\"])\n+\n+        # Fit the polynomial\n+        p = np.polyfit(x_valid, y_valid, self.order)\n+        \n+        # Generate points for the fitted curve\n+        xx = np.linspace(x_valid.min(), x_valid.max(), self.gridsize)\n+        yy = np.polyval(p, xx)\n \n         return pd.DataFrame(dict(x=xx, y=yy))\n \n@@ -40,6 +51,41 @@ class PolyFit(Stat):\n \n         return groupby.apply(data, self._fit_predict)\n \n+    def _check_data(self, x, y):\n+        import warnings\n+        \"\"\"\n+        Check if the data is valid for polynomial fitting.\n+\n+        Parameters:\n+        -----------\n+        x : pandas.Series\n+            The x values for fitting.\n+        y : pandas.Series\n+            The y values for fitting.\n+\n+        Returns:\n+        --------\n+        bool\n+            True if the data is valid for fitting, False otherwise.\n+        \"\"\"\n+        # Filter out rows with missing values\n+        valid_mask = x.notna() & y.notna()\n+        x_valid = x[valid_mask]\n+        y_valid = y[valid_mask]\n+\n+        # Count unique non-null values in x\n+        unique_count = x_valid.nunique()\n+\n+        # Check if there are enough unique non-null values\n+        if unique_count <= self.order:\n+            warnings.warn(\n+                f\"Not enough unique non-null x values to fit a polynomial of order {self.order}. \"\n+                f\"Found {unique_count} unique values, need at least {self.order + 1}.\",\n+                UserWarning\n+            )\n+            return False\n+\n+        return True\n \n @dataclass\n class OLSFit(Stat):\n",
    "resolved": true
}