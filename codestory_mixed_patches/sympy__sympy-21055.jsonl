{
    "instance_id": "sympy__sympy-21055",
    "model_name_or_path": "codestory-mixed",
    "model_patch": "diff --git a/sympy/assumptions/refine.py b/sympy/assumptions/refine.py\nindex e1f97190c0..06e32c5b9d 100644\n--- a/sympy/assumptions/refine.py\n+++ b/sympy/assumptions/refine.py\n@@ -372,6 +372,27 @@ def refine_matrixelement(expr, assumptions):\n         if (i - j).could_extract_minus_sign():\n             return expr\n         return MatrixElement(matrix, j, i)\n+def refine_arg(expr, assumptions):\n+    \"\"\"\n+    Custom handler for refining arg function under certain assumptions.\n+    \"\"\"\n+    import sympy\n+    # Get the argument of the arg function\n+    arg_expr = expr.args[0]\n+    \n+    # Check if the argument is positive, negative, or zero\n+    if ask(Q.positive(arg_expr), assumptions):\n+        return 0  # arg(a) = 0 for positive a\n+    elif ask(Q.negative(arg_expr), assumptions):\n+        return sympy.pi  # arg(a) = pi for negative a\n+    elif ask(Q.zero(arg_expr), assumptions):\n+        return 0  # arg(a) = 0 for zero a\n+    else:\n+        # Additional checks for more complex cases can be added here\n+        pass\n+    \n+    # Return the original expression if no refinement was applied\n+    return expr\n \n handlers_dict = {\n     'Abs': refine_abs,\n@@ -380,5 +401,6 @@ def refine_matrixelement(expr, assumptions):\n     're': refine_re,\n     'im': refine_im,\n     'sign': refine_sign,\n-    'MatrixElement': refine_matrixelement\n+    'MatrixElement': refine_matrixelement,\n+    'arg': refine_arg,\n }  # type: Dict[str, Callable[[Expr, Boolean], Expr]]\ndiff --git a/sympy/functions/elementary/complexes.py b/sympy/functions/elementary/complexes.py\nindex b34ca3a7de..1b64928c63 100644\n--- a/sympy/functions/elementary/complexes.py\n+++ b/sympy/functions/elementary/complexes.py\n@@ -531,6 +531,10 @@ def eval(cls, arg):\n         from sympy.core.function import expand_mul\n         from sympy.core.power import Pow\n \n+        # New check for positive real arguments\n+        if arg.is_positive and arg.is_real:\n+            return arg\n+\n         if hasattr(arg, '_eval_Abs'):\n             obj = arg._eval_Abs()\n             if obj is not None:\n@@ -695,7 +699,11 @@ def _eval_rewrite_as_sign(self, arg, **kwargs):\n \n     def _eval_rewrite_as_conjugate(self, arg, **kwargs):\n         return (arg*conjugate(arg))**S.Half\n-\n+def _eval_refine(self, assumption):\n+    arg = self.args[0]\n+    if assumption.is_positive(arg) or assumption.is_zero(arg):\n+        return arg\n+    return None\n \n class arg(Function):\n     \"\"\"\n@@ -741,6 +749,8 @@ class arg(Function):\n \n     @classmethod\n     def eval(cls, arg):\n+        if arg.is_positive and arg.is_real:\n+            return S.Zero\n         if isinstance(arg, exp_polar):\n             return periodic_argument(arg, oo)\n         if not arg.is_Atom:\n",
    "resolved": true
}