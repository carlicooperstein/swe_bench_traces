{
    "instance_id": "mwaskom__seaborn-2848",
    "model_name_or_path": "codestory-mixed",
    "model_patch": "diff --git a/seaborn/relational.py b/seaborn/relational.py\nindex b1762ca3..906c4bbb 100644\n--- a/seaborn/relational.py\n+++ b/seaborn/relational.py\n@@ -261,6 +261,12 @@ class _RelationalPlotter(VectorPlotter):\n         for level, formatted_level in zip(hue_levels, hue_formatted_levels):\n             if level is not None:\n                 color = self._hue_map(level)\n+                if not isinstance(color, str):\n+                    try:\n+                        color = mpl.colors.rgb2hex(color)\n+                    except ValueError:\n+                        # If color conversion fails, use the original color\n+                        pass\n                 update(self.variables[\"hue\"], formatted_level, color=color)\n \n         # -- Add a legend for size semantics\n@@ -380,15 +386,6 @@ class _LinePlotter(_RelationalPlotter):\n     def plot(self, ax, kws):\n         \"\"\"Draw the plot onto an axes, passing matplotlib kwargs.\"\"\"\n \n-        # Draw a test plot, using the passed in kwargs. The goal here is to\n-        # honor both (a) the current state of the plot cycler and (b) the\n-        # specified kwargs on all the lines we will draw, overriding when\n-        # relevant with the data semantics. Note that we won't cycle\n-        # internally; in other words, if ``hue`` is not used, all elements will\n-        # have the same color, but they will have the color that you would have\n-        # gotten from the corresponding matplotlib function, and calling the\n-        # function will advance the axes property cycle.\n-\n         kws.setdefault(\"markeredgewidth\", kws.pop(\"mew\", .75))\n         kws.setdefault(\"markeredgecolor\", kws.pop(\"mec\", \"w\"))\n \n@@ -407,16 +404,9 @@ class _LinePlotter(_RelationalPlotter):\n             self.estimator, self.errorbar, n_boot=self.n_boot, seed=self.seed,\n         )\n \n-        # TODO abstract variable to aggregate over here-ish. Better name?\n         agg_var = \"y\"\n         grouper = [\"x\"]\n \n-        # TODO How to handle NA? We don't want NA to propagate through to the\n-        # estimate/CI when some values are present, but we would also like\n-        # matplotlib to show \"gaps\" in the line when all values are missing.\n-        # This is straightforward absent aggregation, but complicated with it.\n-        # If we want to use nas, we need to conditionalize dropna in iter_data.\n-\n         # Loop over the semantic subsets and add to the plot\n         grouping_vars = \"hue\", \"size\", \"style\"\n         for sub_vars, sub_data in self.iter_data(grouping_vars, from_comp_data=True):\n@@ -428,15 +418,11 @@ class _LinePlotter(_RelationalPlotter):\n \n             if self.estimator is not None:\n                 if \"units\" in self.variables:\n-                    # TODO eventually relax this constraint\n                     err = \"estimator must be None when specifying units\"\n                     raise ValueError(err)\n                 grouped = sub_data.groupby(grouper, sort=self.sort)\n-                # Could pass as_index=False instead of reset_index,\n-                # but that fails on a corner case with older pandas.\n                 sub_data = grouped.apply(agg, agg_var).reset_index()\n \n-            # TODO this is pretty ad hoc ; see GH2409\n             for var in \"xy\":\n                 if self._log_scaled(var):\n                     for col in sub_data.filter(regex=f\"^{var}\"):\n@@ -444,21 +430,19 @@ class _LinePlotter(_RelationalPlotter):\n \n             # --- Draw the main line(s)\n \n-            if \"units\" in self.variables:   # XXX why not add to grouping variables?\n+            if \"units\" in self.variables:\n                 lines = []\n                 for _, unit_data in sub_data.groupby(\"units\"):\n                     lines.extend(ax.plot(unit_data[\"x\"], unit_data[\"y\"], **kws))\n             else:\n                 lines = ax.plot(sub_data[\"x\"], sub_data[\"y\"], **kws)\n \n+            # Handle hue, size, and style\n             for line in lines:\n-\n                 if \"hue\" in sub_vars:\n                     line.set_color(self._hue_map(sub_vars[\"hue\"]))\n-\n                 if \"size\" in sub_vars:\n                     line.set_linewidth(self._size_map(sub_vars[\"size\"]))\n-\n                 if \"style\" in sub_vars:\n                     attributes = self._style_map(sub_vars[\"style\"])\n                     if \"dashes\" in attributes:\n@@ -474,8 +458,6 @@ class _LinePlotter(_RelationalPlotter):\n \n             if self.estimator is not None and self.errorbar is not None:\n \n-                # TODO handling of orientation will need to happen here\n-\n                 if self.err_style == \"band\":\n \n                     ax.fill_between(\n@@ -576,7 +558,11 @@ class _ScatterPlotter(_RelationalPlotter):\n         # Apply the mapping from semantic variables to artist attributes\n \n         if \"hue\" in self.variables:\n-            points.set_facecolors(self._hue_map(data[\"hue\"]))\n+            hue_values = data[\"hue\"]\n+            if pd.api.types.is_categorical_dtype(hue_values):\n+                hue_values = hue_values.astype(str)\n+            colors = self._hue_map(hue_values)\n+            points.set_facecolors(colors)\n \n         if \"size\" in self.variables:\n             points.set_sizes(self._size_map(data[\"size\"]))\n",
    "resolved": false
}