{
    "instance_id": "sympy__sympy-12481",
    "model_name_or_path": "codestory-mixed",
    "model_patch": "diff --git a/sympy/combinatorics/permutations.py b/sympy/combinatorics/permutations.py\nindex 136ed5a478..ed304394ca 100644\n--- a/sympy/combinatorics/permutations.py\n+++ b/sympy/combinatorics/permutations.py\n@@ -878,7 +878,6 @@ def __new__(cls, *args, **kwargs):\n             raise ValueError(\"Permutation argument must be a list of ints, \"\n                              \"a list of lists, Permutation or Cycle.\")\n \n-\n         # safe to assume args are valid; this also makes a copy\n         # of the args\n         args = list(args[0])\n@@ -897,26 +896,30 @@ def __new__(cls, *args, **kwargs):\n         temp = flatten(args)\n         if has_dups(temp):\n             if is_cycle:\n-                raise ValueError('there were repeated elements; to resolve '\n-                'cycles use Cycle%s.' % ''.join([str(tuple(c)) for c in args]))\n+                # Apply non-disjoint cycles in left-to-right order\n+                c = Cycle()\n+                for ci in args:\n+                    c = c(*ci)\n+                aform = c.list()\n             else:\n                 raise ValueError('there were repeated elements.')\n-        temp = set(temp)\n-\n-        if not is_cycle and \\\n-                any(i not in temp for i in range(len(temp))):\n-            raise ValueError(\"Integers 0 through %s must be present.\" %\n-                             max(temp))\n-\n-        if is_cycle:\n-            # it's not necessarily canonical so we won't store\n-            # it -- use the array form instead\n-            c = Cycle()\n-            for ci in args:\n-                c = c(*ci)\n-            aform = c.list()\n         else:\n-            aform = list(args)\n+            temp = set(temp)\n+            if not is_cycle and \\\n+                    any(i not in temp for i in range(len(temp))):\n+                raise ValueError(\"Integers 0 through %s must be present.\" %\n+                                 max(temp))\n+\n+            if is_cycle:\n+                # it's not necessarily canonical so we won't store\n+                # it -- use the array form instead\n+                c = Cycle()\n+                for ci in args:\n+                    c = c(*ci)\n+                aform = c.list()\n+            else:\n+                aform = list(args)\n+\n         if size and size > len(aform):\n             # don't allow for truncation of permutation which\n             # might split a cycle and lead to an invalid aform\n@@ -927,6 +930,24 @@ def __new__(cls, *args, **kwargs):\n         obj._array_form = aform\n         obj._size = size\n         return obj\n+        obj._array_form = aform\n+        obj._size = size\n+        return obj\n+        obj._array_form = aform\n+        obj._size = size\n+        return obj\n+        obj._array_form = aform\n+        obj._size = size\n+        return obj\n+        obj._array_form = aform\n+        obj._size = size\n+        return obj\n+        obj._array_form = aform\n+        obj._size = size\n+        return obj\n+        obj._array_form = aform\n+        obj._size = size\n+        return obj\n \n     @staticmethod\n     def _af_new(perm):\n",
    "resolved": true
}